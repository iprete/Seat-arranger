<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>자리배치표 - 고급 탐색</title>
  <style>
  </style>
</head>
<body>
  <div class="container">
    <h1>자리배치표 - 고급 탐색</h1>

    <!-- 입력 영역 -->
    <div class="input-group">
      <label>인원 수:</label>
      <input id="numPeople" type="number" value="12" />
    </div>
    <div class="input-group">
      <label>줄(행) 개수:</label>
      <input id="numRows" type="number" value="3" />
    </div>
    <div class="input-group">
      <label>앞자리 선호자 (번호 쉼표로 구분):</label>
      <input id="frontPref" type="text" value="1,3,5" />
    </div>
    <div class="input-group">
      <label>뒷자리 선호자 (번호 쉼표로 구분):</label>
      <input id="backPref" type="text" value="10,11,12" />
    </div>
    <div class="input-group">
      <label>같이 앉기 싫은 쌍 (번호,번호 / 번호,번호):</label>
      <input id="notTogether" type="text" value="1,2/3,4" />
    </div>
    <div class="input-group">
      <label>고급 탐색 수준 (숫자 클수록 정밀 탐색):</label>
      <input id="popSize" type="number" value="30" />
    </div>
    <div class="input-group">
      <label>최적화 단계 (많을수록 오래 걸림):</label>
      <input id="generations" type="number" value="15" />
    </div>

    <div class="buttons">
      <button onclick="app.init()">좌석 생성하기</button>
      <button id="assignSeatsAdvancedButton" onclick="app.assignSeatsAdvanced()">고급 자리 배치</button>
      <button onclick="app.downloadPDF()">PDF 저장</button>
    </div>

    <!-- 로딩 바 -->
    <div id="loadingContainer" style="display:none; margin:10px 0; background:#ccc; height:20px; border-radius:5px; overflow:hidden;">
      <div id="loadingBar" style="height:100%; width:0%; background:#5f69d0; transition:width 0.2s ease;"></div>
    </div>

    <!-- 표가 들어갈 영역 -->
    <div id="gridArea"></div>
    <!-- 조건 이행률 및 처리시간 표시 -->
    <div id="scoreArea"></div>
  </div>

  <div class="footer">made by 20707 with GPT</div>

  <!-- jsPDF (PDF 변환) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    // ---------- 유틸: 사람 번호를 '숫자'로 일관되게 관리 ----------
    function parseList(str) {
      if (!str) return [];
      return str.split(',')
        .map(x => x.trim())
        .filter(x => x !== '')
        .map(x => parseInt(x, 10)); // 꼭 숫자로 변환
    }
    // notPairs를 /로 나눈 뒤, 각 쌍(a,b)도 숫자로
    function parseNotPairs(str) {
      if (!str) return [];
      return str.split('/')
        .map(p => p.split(',').map(x => parseInt(x.trim(),10)))
        .filter(arr => arr.length === 2); // [a,b]
    }

    // Fisher-Yates 섞기
    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
    }
    // PMX (Partially Mapped Crossover)
    function pmxCrossover(parent1, parent2) {
      const size = parent1.length;
      let child = new Array(size).fill(null);
      let start = Math.floor(Math.random() * size);
      let end = Math.floor(Math.random() * size);
      if (start > end) [start, end] = [end, start];
      for (let i = start; i <= end; i++) {
        child[i] = parent1[i];
      }
      for (let i = start; i <= end; i++) {
        const gene = parent2[i];
        if (!child.includes(gene)) {
          let pos = i;
          while (true) {
            const geneFromP1 = parent1[pos];
            const pos2 = parent2.indexOf(geneFromP1);
            if (child[pos2] === null) {
              child[pos2] = gene;
              break;
            } else {
              pos = pos2;
            }
          }
        }
      }
      for (let i = 0; i < size; i++) {
        if (child[i] === null) {
          child[i] = parent2[i];
        }
      }
      return child;
    }
    // swap mutation
    function swapMutation(arr) {
      const size = arr.length;
      let i1 = Math.floor(Math.random() * size);
      let i2 = Math.floor(Math.random() * size);
      while (i1 === i2) {
        i2 = Math.floor(Math.random() * size);
      }
      [arr[i1], arr[i2]] = [arr[i2], arr[i1]];
    }
    // 순열 배열 → mapping
    function arrayToMapping(arr, seats) {
      const mapping = {};
      for (let i = 0; i < arr.length; i++) {
        mapping[seats[i].id] = arr[i];
      }
      return mapping;
    }

    // --- 로컬 탐색(후처리): 가까운 스왑으로 더 나은 해를 찾음 ---
    function localSearch(bestCandidate, seats, frontArr, backArr, notPairs) {
      let improved = true;
      let best = bestCandidate;
      while (improved) {
        improved = false;
        for (let i = 0; i < best.perm.length - 1; i++) {
          for (let j = i + 1; j < best.perm.length; j++) {
            const newPerm = [...best.perm];
            [newPerm[i], newPerm[j]] = [newPerm[j], newPerm[i]];
            const newMapping = arrayToMapping(newPerm, seats);
            const newFitness = app.calculateFitness(newMapping, seats, frontArr, backArr, notPairs);
            if (newFitness > best.fitness) {
              best = { mapping: newMapping, fitness: newFitness, perm: newPerm };
              improved = true;
            }
          }
        }
      }
      return best;
    }

    // --------------------- 메인 객체 ---------------------
    const app = {
      seatMatrix: [],
      excludedSeats: new Set(),
      tdElements: {},
      isAssigning: false, // 중복 실행 방지

      init() {
        this.seatMatrix = [];
        this.excludedSeats.clear();
        this.tdElements = {};
        document.getElementById('gridArea').innerHTML = '';
        document.getElementById('scoreArea').textContent = '';

        const chk = this.checkInputs();
        if (!chk.ok) {
          alert(chk.msg);
          return;
        }
        const { numPeople, numRows } = chk;
        const numCols = Math.ceil(numPeople / numRows);

        let html = '<table>';
        html += `<tr><td class="desk-td" colspan="${numCols}">교탁</td></tr>`;
        for (let r = 0; r < numRows; r++) {
          html += '<tr>';
          const rowArr = [];
          for (let c = 0; c < numCols; c++) {
            const cellId = `r${r}c${c}`;
            rowArr.push(cellId);
            html += `<td id="${cellId}">-</td>`;
          }
          this.seatMatrix.push(rowArr);
          html += '</tr>';
        }
        html += '</table>';
        document.getElementById('gridArea').innerHTML = html;

        // 각 좌석 클릭 시 수동 제외(토글)
        for (let r = 0; r < this.seatMatrix.length; r++) {
          for (let c = 0; c < this.seatMatrix[r].length; c++) {
            const cid = this.seatMatrix[r][c];
            const td = document.getElementById(cid);
            if (td) {
              td.onclick = () => this.toggleSeat(cid);
              this.tdElements[cid] = td;
            }
          }
        }
      },

      toggleSeat(cellId) {
        if (!this.tdElements[cellId]) return;
        if (this.excludedSeats.has(cellId)) {
          this.excludedSeats.delete(cellId);
          this.tdElements[cellId].classList.remove('excluded');
        } else {
          this.excludedSeats.add(cellId);
          this.tdElements[cellId].classList.add('excluded');
        }
      },

      async assignSeatsAdvanced() {
        if (this.isAssigning) {
          alert("이미 계산 중입니다.");
          return;
        }
        this.isAssigning = true;
        document.getElementById("assignSeatsAdvancedButton").disabled = true;

        const chk = this.checkInputs();
        if (!chk.ok) {
          alert(chk.msg);
          this.isAssigning = false;
          document.getElementById("assignSeatsAdvancedButton").disabled = false;
          return;
        }
        if (!this.seatMatrix.length) {
          alert('먼저 [좌석 생성하기] 버튼을 눌러주세요.');
          this.isAssigning = false;
          document.getElementById("assignSeatsAdvancedButton").disabled = false;
          return;
        }
        const { numPeople, frontArr, backArr, notPairs, popSize, generations } = chk;

        // 제외되지 않은 좌석만 추려서 사용
        const availableSeats = [];
        for (let r = 0; r < this.seatMatrix.length; r++) {
          for (let c = 0; c < this.seatMatrix[r].length; c++) {
            const cid = this.seatMatrix[r][c];
            if (!this.excludedSeats.has(cid)) {
              availableSeats.push({ row: r, col: c, id: cid });
            }
          }
        }
        if (availableSeats.length !== numPeople) {
          alert('사용 가능한 좌석 수가 인원 수와 정확히 맞지 않습니다. 수동으로 좌석을 제외하거나 복원해주세요.');
          this.isAssigning = false;
          document.getElementById("assignSeatsAdvancedButton").disabled = false;
          return;
        }
        availableSeats.sort((a, b) => (a.row - b.row) || (a.col - b.col));
        const seats = availableSeats;

        // 로딩 바 표시
        const loadingContainer = document.getElementById('loadingContainer');
        const loadingBar = document.getElementById('loadingBar');
        loadingContainer.style.display = 'block';
        loadingBar.style.width = '0%';

        // GA 초기 population
        const startTime = performance.now();
        const peopleArr = Array.from({ length: numPeople }, (_, i) => i + 1); // 숫자로
        let population = [];
        for (let i = 0; i < popSize; i++) {
          const perm = [...peopleArr];
          shuffle(perm);
          const mapping = arrayToMapping(perm, seats);
          population.push({ mapping, fitness: 0, perm });
        }

        // 적응형 돌연변이 관련 변수
        let mutationProb = 0.3;
        let previousBestFitness = -Infinity;

        // GA 메인 루프
        for (let g = 0; g < generations; g++) {
          for (let p of population) {
            p.fitness = this.calculateFitness(p.mapping, seats, frontArr, backArr, notPairs);
          }
          population.sort((a, b) => b.fitness - a.fitness);

          // 돌연변이 확률 조정
          const currentBestFitness = population[0].fitness;
          if (currentBestFitness - previousBestFitness < 0.001) {
            mutationProb = Math.min(mutationProb + 0.05, 0.5);
          } else {
            mutationProb = Math.max(mutationProb - 0.05, 0.1);
          }
          previousBestFitness = currentBestFitness;

          // 엘리트 보존
          const eliteCount = Math.floor(popSize * 0.2);
          const newPop = population.slice(0, eliteCount);

          // 나머지 개체 채우기
          while (newPop.length < popSize) {
            const p1 = this.tournamentSelection(population);
            const p2 = this.tournamentSelection(population);
            const childPerm = pmxCrossover(p1.perm, p2.perm);
            if (Math.random() < mutationProb) {
              swapMutation(childPerm);
            }
            const childMapping = arrayToMapping(childPerm, seats);
            newPop.push({ mapping: childMapping, fitness: 0, perm: childPerm });
          }
          population = newPop;

          // 진행도 표시
          loadingBar.style.width = ((g + 1) / generations * 100) + '%';
          await new Promise(res => setTimeout(res, 0));
        }
        // 최적 해
        population.sort((a, b) => b.fitness - a.fitness);
        let best = population[0];

        // 로컬 탐색 후처리
        best = localSearch(best, seats, frontArr, backArr, notPairs);

        // 결과 반영
        for (let s of seats) {
          const pid = best.mapping[s.id];
          this.tdElements[s.id].textContent = pid === undefined ? '-' : pid;
        }
        const ratio = this.computeSatisfaction(best.mapping, seats, notPairs);
        const endTime = performance.now();
        const sec = ((endTime - startTime) / 1000).toFixed(2);
        document.getElementById('scoreArea').textContent =
          `조건이행률: ${ratio.toFixed(2)}%, 처리시간: ${sec}초`;

        loadingContainer.style.display = 'none';
        this.isAssigning = false;
        document.getElementById("assignSeatsAdvancedButton").disabled = false;
      },

      // ---------------------------------------------------------------------
      // calculateFitness: 거리가 '너무' 가까우면 큰 벌점(음수)을 주는 방식
      // ---------------------------------------------------------------------
      calculateFitness(mapping, seats, frontArr, backArr, notPairs) {
        let sc = 0;

        // --- (1) 싫은 쌍 거리 ---
        // threshold = 4 이상이면 어느정도 떨어짐, 이하이면 큰 벌점
        // 여기서는 예시로 d<4면 sc -= (4-d)*20 처럼 감점을 주어 최대한 떨어뜨리게 함
        const threshold = 4;
        for (let [p1, p2] of notPairs) {
          let s1 = null, s2 = null;
          for (let s of seats) {
            if (mapping[s.id] === p1) s1 = s;
            if (mapping[s.id] === p2) s2 = s;
            if (s1 && s2) break;
          }
          if (s1 && s2) {
            const d = Math.abs(s1.row - s2.row) + Math.abs(s1.col - s2.col);
            if (d < threshold) {
              // 가까울수록 큰 벌점
              sc -= (threshold - d) * 20; 
            } else {
              // 충분히 떨어짐
              sc += 10; 
            }
          }
        }

        // --- (2) 앞자리, 뒷자리 선호 ---
        for (let s of seats) {
          const pid = mapping[s.id];
          if (pid === undefined) continue;
          if (frontArr.includes(pid)) {
            // 행 번호가 낮을수록 보상
            sc += (this.seatMatrix.length - s.row) * 10;
          }
          if (backArr.includes(pid)) {
            sc += s.row * 2;
          }
        }
        return sc;
      },

      // ---------------------------------------------------------------------
      // computeSatisfaction: 거리 6 이상이면 100%, 미만이면 (d/6)
      // ---------------------------------------------------------------------
      computeSatisfaction(mapping, seats, notPairs) {
        if (!notPairs.length) return 100;
        let sumRatio = 0, cnt = 0;
        const threshold = 6;
        for (let [a, b] of notPairs) {
          let s1 = null, s2 = null;
          for (let s of seats) {
            if (mapping[s.id] === a) s1 = s;
            if (mapping[s.id] === b) s2 = s;
            if (s1 && s2) break;
          }
          if (s1 && s2) {
            const d = Math.abs(s1.row - s2.row) + Math.abs(s1.col - s2.col);
            const ratio = d >= threshold ? 1 : d / threshold;
            sumRatio += ratio;
            cnt++;
          }
        }
        if (cnt === 0) return 100;
        return (sumRatio / cnt) * 100;
      },

      // 토너먼트 선택
      tournamentSelection(pop) {
        const tSize = 3;
        let best = null;
        for (let i = 0; i < tSize; i++) {
          const candidate = pop[Math.floor(Math.random() * pop.length)];
          if (!best || candidate.fitness > best.fitness) {
            best = candidate;
          }
        }
        return best;
      },

      downloadPDF() {
        const table = document.querySelector('#gridArea table');
        if (!table) {
          alert('먼저 [좌석 생성하기] 및 [고급 자리 배치]를 진행해주세요.');
          return;
        }
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        let y = 10;
        for (const row of table.rows) {
          let x = 10;
          for (const cell of row.cells) {
            doc.text(cell.textContent, x, y);
            x += 20;
          }
          y += 10;
        }
        doc.save('자리배치.pdf');
      },

      // ---------------------------------------------------------------------
      // checkInputs: 기본 입력 파싱 -> 숫자
      // ---------------------------------------------------------------------
      checkInputs() {
        const np = parseInt(document.getElementById('numPeople').value, 10);
        const nr = parseInt(document.getElementById('numRows').value, 10);
        const frontStr = document.getElementById('frontPref').value.trim();
        const backStr  = document.getElementById('backPref').value.trim();
        const ntStr   = document.getElementById('notTogether').value.trim();
        const popSz   = parseInt(document.getElementById('popSize').value, 10);
        const gens    = parseInt(document.getElementById('generations').value, 10);

        if (isNaN(np) || np < 1) return { ok: false, msg: '인원 수를 1 이상으로' };
        if (isNaN(nr) || nr < 1) return { ok: false, msg: '줄(행) 개수를 1 이상으로' };
        if (isNaN(popSz) || popSz < 2) return { ok: false, msg: '고급 탐색 수준은 2 이상으로' };
        if (isNaN(gens) || gens < 1) return { ok: false, msg: '최적화 단계는 1 이상으로' };

        const frontArr = parseList(frontStr);
        const backArr  = parseList(backStr);
        const notPairs = parseNotPairs(ntStr);

        // 범위 체크, 중복 등
        // (예시만, 필요하면 더 세부 검증)
        for (let x of frontArr) {
          if (x<1 || x>np) return { ok:false, msg:`앞자리선호 ${x}가 범위 초과` };
        }
        for (let x of backArr) {
          if (x<1 || x>np) return { ok:false, msg:`뒷자리선호 ${x}가 범위 초과` };
        }
        for (let [a,b] of notPairs) {
          if (a<1||a>np || b<1||b>np) {
            return { ok:false, msg:`싫은쌍 (${a},${b}) 범위 초과`};
          }
        }

        return {
          ok:true,
          numPeople: np,
          numRows: nr,
          frontArr,
          backArr,
          notPairs,
          popSize: popSz,
          generations: gens
        };
      }
    };
  </script>
</body>
</html>
