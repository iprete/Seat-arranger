<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>자리배치표 - 고급 탐색</title>
  <style>
    body{font-family:sans-serif;margin:0;padding:0;background:#f9f9fc}
    .container{max-width:650px;margin:30px auto;padding:20px;background:white;box-shadow:0 0 10px rgba(0,0,0,0.1);border-radius:10px}
    h1{text-align:center;margin-bottom:20px;font-weight:600;color:#333}
    .input-group{margin-bottom:15px}
    .input-group label{display:block;margin-bottom:5px;font-weight:bold}
    .input-group input{width:100%;padding:8px 10px;border:1px solid #ccc;border-radius:5px;outline:none}
    .buttons{display:flex;flex-direction:column;gap:10px;margin-bottom:20px}
    .buttons button{padding:12px;border:none;border-radius:5px;background:#737ee0;color:white;font-size:14px;cursor:pointer;transition:background 0.2s ease}
    .buttons button:hover{background:#5f69d0}
    table{border-collapse:separate;border-spacing:10px;margin:0 auto;margin-top:20px}
    td{border:1px solid #aaa;padding:10px;text-align:center;width:60px;height:60px;cursor:pointer;background:#fafafa;position:relative;transition:background 0.3s ease}
    td:hover{background:#ececff}
    td.excluded{background-color:#4da6ff;color:white;font-weight:bold}
    td.desk-td{background-color:#ffe67e;color:#444;font-weight:bold;cursor:default;width:auto}
    .footer{text-align:center;font-size:12px;color:#777;margin-top:40px;margin-bottom:10px}
    #scoreArea{text-align:center;margin-top:10px;font-weight:bold;color:#333}
    #progressContainer{width:100%;background:#ddd; border-radius:5px; margin:20px 0; height:20px; display:block;}
    #progressBar{width:0%;height:20px;background:#4CAF50;color:white;text-align:center;line-height:20px;font-size:14px; border-radius:5px;}
  </style>
</head>
<body>
  <div class="container">
    <h1>자리배치표 - 고급 탐색</h1>
    <div class="input-group">
      <label>인원 수:</label>
      <input id="numPeople" type="number" value="33" />
    </div>
    <div class="input-group">
      <label>줄(행) 개수:</label>
      <input id="numRows" type="number" value="6" />
    </div>
    <div class="input-group">
      <label>앞자리 선호자 (번호 쉼표로 구분):</label>
      <input id="frontPref" type="text" placeholder="예: 1,3,5" value="1,3,5" />
    </div>
    <div class="input-group">
      <label>뒷자리 선호자 (번호 쉼표로 구분):</label>
      <input id="backPref" type="text" placeholder="예: 10,11,12" value="10,11,12" />
    </div>
    <div class="input-group">
      <label>같이 앉기 싫은 그룹 (번호,번호,번호 / 번호,번호):</label>
      <input id="notTogether" type="text" placeholder="예: 1,2,3/4,5" value="1,2,3/4,5" />
    </div>
    <div class="input-group">
      <label>고급 탐색 수준 (숫자 클수록 정밀 탐색):</label>
      <input id="popSize" type="number" value="30" />
    </div>
    <div class="input-group">
      <label>최적화 단계 (많을수록 오래 걸림):</label>
      <input id="generations" type="number" value="15" />
    </div>
    <div class="buttons">
      <button onclick="app.init()">좌석 생성하기</button>
      <button onclick="app.assignSeatsAdvanced()">고급 자리 배치</button>
      <button onclick="app.downloadPDF()">PDF 저장</button>
    </div>
    <div id="gridArea"></div>
    <div id="progressContainer" style="display:none;">
      <div id="progressBar">0%</div>
    </div>
    <div id="scoreArea"></div>
  </div>
  <div class="footer">made by 20707 with GPT</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}}
    function parseList(str){if(!str)return[];return str.split(',').map(x=>x.trim()).filter(x=>x!=='')}
    function hasDup(arr){return new Set(arr).size!==arr.length}
    function pmxCrossover(p1,p2){
      const size=p1.length;
      let child=new Array(size).fill(null);
      let start=Math.floor(Math.random()*size);
      let end=Math.floor(Math.random()*size);
      if(start>end)[start,end]=[end,start];
      for(let i=start;i<=end;i++){child[i]=p1[i]}
      for(let i=start;i<=end;i++){
        const gene=p2[i];
        if(!child.includes(gene)){
          let pos=i;
          while(true){
            const geneFromP1=p1[pos];
            const pos2=p2.indexOf(geneFromP1);
            if(child[pos2]===null){child[pos2]=gene;break}else{pos=pos2}
          }
        }
      }
      for(let i=0;i<size;i++){if(child[i]===null){child[i]=p2[i]}}
      return child;
    }
    function swapMutation(a){
      const size=a.length;
      let i1=Math.floor(Math.random()*size);
      let i2=Math.floor(Math.random()*size);
      while(i1===i2){i2=Math.floor(Math.random()*size)}
      [a[i1],a[i2]]=[a[i2],a[i1]];
    }
    function arrayToMapping(arr,seats){
      const mapping={};
      for(let i=0;i<arr.length;i++){
        mapping[seats[i].id]=arr[i];
      }
      return mapping;
    }
    const app={
      seatMatrix:[],
      excludedSeats:new Set(),
      tdElements:{},
      isProcessing:false,
      init(){
        this.seatMatrix=[];
        this.excludedSeats.clear();
        this.tdElements={};
        document.getElementById('gridArea').innerHTML='';
        document.getElementById('scoreArea').textContent='';
        document.getElementById('progressContainer').style.display='none';
        const chk=this.checkInputs();
        if(!chk.ok){alert(chk.msg);return}
        const {numPeople,numRows}=chk;
        const numCols=Math.ceil(numPeople/numRows);
        let html='<table>';
        html+=`<tr><td class="desk-td" colspan="${numCols}">교탁</td></tr>`;
        for(let r=0;r<numRows;r++){
          html+='<tr>';
          let rowArr=[];
          for(let c=0;c<numCols;c++){
            const cellId=`r${r}c${c}`;
            rowArr.push(cellId);
            html+=`<td id="${cellId}">-</td>`;
          }
          this.seatMatrix.push(rowArr);
          html+='</tr>';
        }
        html+='</table>';
        document.getElementById('gridArea').innerHTML=html;
        for(let r=0;r<this.seatMatrix.length;r++){
          for(let c=0;c<this.seatMatrix[r].length;c++){
            const cid=this.seatMatrix[r][c];
            const td=document.getElementById(cid);
            if(td){td.onclick=()=>this.toggleSeat(cid);this.tdElements[cid]=td}
          }
        }
      },
      toggleSeat(cellId){
        if(!this.tdElements[cellId])return;
        if(this.excludedSeats.has(cellId)){
          this.excludedSeats.delete(cellId);
          this.tdElements[cellId].classList.remove('excluded');
        } else {
          this.excludedSeats.add(cellId);
          this.tdElements[cellId].classList.add('excluded');
        }
      },
      async assignSeatsAdvanced(){
        if(this.isProcessing){alert("자리 배치 중입니다. 잠시 기다려 주세요.");return}
        this.isProcessing=true;
        const chk=this.checkInputs();
        if(!chk.ok){alert(chk.msg);this.isProcessing=false;return}
        if(!this.seatMatrix.length){alert('먼저 [좌석 생성하기] 버튼을 눌러주세요.');this.isProcessing=false;return}
        const {numPeople,frontArr,backArr,notGroups,popSize,generations}=chk;
        let availableSeats=[];
        for(let r=0;r<this.seatMatrix.length;r++){
          for(let c=0;c<this.seatMatrix[r].length;c++){
            const cid=this.seatMatrix[r][c];
            if(!this.excludedSeats.has(cid)){availableSeats.push({row:r,col:c,id:cid})}
          }
        }
        if(availableSeats.length!==numPeople){
          alert(`현재 제외되지 않은 좌석은 ${availableSeats.length}개입니다. 인원 수 ${numPeople}과 일치해야 합니다.`);
          this.isProcessing=false;
          return;
        }
        availableSeats.sort((a,b)=>(a.row-b.row)||(a.col-b.col));
        const seats=availableSeats.slice(0,numPeople);
        const startTime=performance.now();
        const peopleArr=Array.from({length:numPeople},(_,i)=>(i+1).toString());
        let population=[];
        for(let i=0;i<popSize;i++){
          let perm=[...peopleArr];
          shuffle(perm);
          let mapping=arrayToMapping(perm,seats);
          population.push({mapping,fitness:0,perm});
        }
        // 로딩바 보이기
        document.getElementById('progressContainer').style.display='block';
        document.getElementById('progressBar').style.width="0%";
        document.getElementById('progressBar').textContent="0%";
        let bestFitnessOld=-Infinity, stagnantCount=0, mutationProbability=0.2;
        for(let g=0;g<generations;g++){
          for(let p of population){
            p.fitness=this.calculateFitness(p.mapping,seats,frontArr,backArr,notGroups);
          }
          population.sort((a,b)=>b.fitness-a.fitness);
          if(population[0].fitness>bestFitnessOld){
            bestFitnessOld=population[0].fitness;
            stagnantCount=0;
            mutationProbability=0.2;
          } else {
            stagnantCount++;
            if(stagnantCount>=5){
              mutationProbability=0.3;
            }
          }
          const eliteCount=Math.floor(popSize*0.2);
          const newPop=population.slice(0,eliteCount);
          while(newPop.length<popSize){
            const parent1=this.tournamentSelection(population);
            const parent2=this.tournamentSelection(population);
            const childPerm=pmxCrossover(parent1.perm,parent2.perm);
            if(Math.random()<mutationProbability){
              swapMutation(childPerm);
            }
            const childMapping=arrayToMapping(childPerm,seats);
            newPop.push({mapping:childMapping,fitness:0,perm:childPerm});
          }
          population=newPop;
          let progress=Math.floor(((g+1)/generations)*100);
          document.getElementById('progressBar').style.width=progress+"%";
          document.getElementById('progressBar').textContent=progress+"%";
          await new Promise(resolve=>setTimeout(resolve,0));
        }
        population.sort((a,b)=>b.fitness-a.fitness);
        const best=population[0];
        for(let s of seats){
          const pid=best.mapping[s.id];
          this.tdElements[s.id].textContent=pid||'-';
        }
        const ratio=this.computeSatisfaction(best.mapping,seats,notGroups);
        const endTime=performance.now();
        const sec=((endTime-startTime)/1000).toFixed(2);
        document.getElementById('scoreArea').innerHTML=`조건이행률: ${ratio.toFixed(2)}%, 처리시간: ${sec}초`;
        this.isProcessing=false;
      },
      tournamentSelection(population){
        const tournamentSize=3;
        let best=null;
        for(let i=0;i<tournamentSize;i++){
          const candidate=population[Math.floor(Math.random()*population.length)];
          if(!best||candidate.fitness>best.fitness){best=candidate}
        }
        return best;
      },
      calculateFitness(mapping,seats,frontArr,backArr,notGroups){
        let sc=0;
        for(let group of notGroups){
          for(let i=0;i<group.length;i++){
            for(let j=i+1;j<group.length;j++){
              let p1=group[i], p2=group[j];
              let s1=null,s2=null;
              for(let s of seats){
                if(mapping[s.id]===p1)s1=s;
                if(mapping[s.id]===p2)s2=s;
                if(s1&&s2)break;
              }
              if(s1&&s2){let d=Math.abs(s1.row-s2.row)+Math.abs(s1.col-s2.col);sc+=d*10}
            }
          }
        }
        for(let s of seats){
          const pid=mapping[s.id];
          if(!pid)continue;
          if(frontArr.includes(pid)){
            if(s.row<3){sc+=(5-s.row)}else{sc-=10*(s.row-2)}
          }
          if(backArr.includes(pid)){sc+=(s.row*2)}
        }
        return sc;
      },
      computeSatisfaction(mapping,seats,notGroups){
        if(!notGroups.length)return 100;
        const rowMax=this.seatMatrix.length;
        const colMax=Math.max(...this.seatMatrix.map(row=>row.length));
        const maxDist=(rowMax-1)+(colMax-1);
        let sumRatio=0, cnt=0;
        for(let group of notGroups){
          for(let i=0;i<group.length;i++){
            for(let j=i+1;j<group.length;j++){
              let p1=group[i], p2=group[j];
              let s1=null,s2=null;
              for(let s of seats){
                if(mapping[s.id]===p1)s1=s;
                if(mapping[s.id]===p2)s2=s;
                if(s1&&s2)break;
              }
              if(s1&&s2){let d=Math.abs(s1.row-s2.row)+Math.abs(s1.col-s2.col);sumRatio+=(d/maxDist);cnt++}
            }
          }
        }
        if(cnt===0)return 100;
        return (sumRatio/cnt)*100;
      },
      downloadPDF(){
        const table=document.querySelector('#gridArea table');
        if(!table){alert('먼저 [좌석 생성하기] & [고급 자리 배치]를 해주세요.');return}
        const {jsPDF}=window.jspdf;
        const doc=new jsPDF();
        let y=10;
        for(const row of table.rows){
          let x=10;
          for(const cell of row.cells){doc.text(cell.textContent,x,y);x+=20}
          y+=10;
        }
        doc.save('자리배치.pdf');
      },
      checkInputs(){
        const np=parseInt(document.getElementById('numPeople').value,10);
        const nr=parseInt(document.getElementById('numRows').value,10);
        const fp=document.getElementById('frontPref').value.trim();
        const bp=document.getElementById('backPref').value.trim();
        const nt=document.getElementById('notTogether').value.trim();
        const popSz=parseInt(document.getElementById('popSize').value,10);
        const gens=parseInt(document.getElementById('generations').value,10);
        if(isNaN(np)||np<1)return {ok:false,msg:'인원 수를 1 이상으로'};
        if(isNaN(nr)||nr<1)return {ok:false,msg:'줄(행) 수를 1 이상으로'};
        if(isNaN(popSz)||popSz<2)return {ok:false,msg:'고급 탐색 수준은 2 이상으로'};
        if(isNaN(gens)||gens<1)return {ok:false,msg:'최적화 단계는 1 이상으로'};
        const frontArr=parseList(fp);
        const backArr=parseList(bp);
        if(hasDup(frontArr))return {ok:false,msg:'앞자리 선호 중 중복 있음'};
        if(hasDup(backArr))return {ok:false,msg:'뒷자리 선호 중 중복 있음'};
        for(let f of frontArr){if(backArr.includes(f))return {ok:false,msg:`${f}가 앞뒤 선호 중복`}}
        for(let v of [...frontArr,...backArr]){
          const x=parseInt(v,10);
          if(x<1||x>np)return {ok:false,msg:`선호번호 ${v}가 인원수 범위 초과`};
        }
        let notGroups=[];
        if(nt!==''){
          let arr=nt.split('/');
          for(let groupStr of arr){
            let group=groupStr.split(',').map(x=>x.trim()).filter(x=>x!=='');
            if(group.length<2)return {ok:false,msg:'같이 앉기 싫은 그룹은 최소 2명 이상이어야 함'};
            if(hasDup(group))return {ok:false,msg:'같이 앉기 싫은 그룹 내 중복 있음'};
            for(let vv of group){
              const x=parseInt(vv,10);
              if(x<1||x>np)return {ok:false,msg:`그룹 내 번호 ${vv}가 인원수 범위 초과`};
            }
            notGroups.push(group);
          }
        }
        return {ok:true,numPeople:np,numRows:nr,frontArr,backArr,notGroups,popSize:popSz,generations:gens};
      }
    };
  </script>
</body>
</html>
