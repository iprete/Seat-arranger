<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>자리배치표 - 고급 탐색</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      background: #f9f9fc;
    }
    .container {
      max-width: 650px;
      margin: 30px auto;
      padding: 20px;
      background: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      border-radius: 10px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-weight: 600;
      color: #333;
    }
    .input-group {
      margin-bottom: 15px;
    }
    .input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .input-group input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      outline: none;
    }
    .buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .buttons button {
      padding: 12px;
      border: none;
      border-radius: 5px;
      background: #737ee0;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .buttons button:hover {
      background: #5f69d0;
    }
    table {
      border-collapse: separate;
      border-spacing: 10px;
      margin: 0 auto;
      margin-top: 20px;
    }
    td {
      border: 1px solid #aaa;
      padding: 10px;
      text-align: center;
      width: 60px;
      height: 60px;
      cursor: pointer;
      background: #fafafa;
      position: relative;
      transition: background 0.3s ease;
    }
    td:hover {
      background: #ececff;
    }
    td.excluded {
      background-color: #4da6ff;
      color: white;
      font-weight: bold;
    }
    td.desk-td {
      background-color: #ffe67e;
      color: #444;
      font-weight: bold;
      cursor: default;
      width: auto;
    }
    .footer {
      text-align: center;
      font-size: 12px;
      color: #777;
      margin-top: 40px;
      margin-bottom: 10px;
    }
    #scoreArea {
      text-align: center;
      margin-top: 10px;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>자리배치표 - 고급 탐색</h1>

    <!-- 입력 영역 -->
    <div class="input-group">
      <label>인원 수:</label>
      <input id="numPeople" type="number" value="12" />
    </div>
    <div class="input-group">
      <label>줄(행) 개수:</label>
      <input id="numRows" type="number" value="3" />
    </div>
    <div class="input-group">
      <label>앞자리 선호자 (번호 쉼표로 구분):</label>
      <input id="frontPref" type="text" placeholder="예: 1,3,5" value="1,3,5" />
    </div>
    <div class="input-group">
      <label>뒷자리 선호자 (번호 쉼표로 구분):</label>
      <input id="backPref" type="text" placeholder="예: 10,11,12" value="10,11,12" />
    </div>
    <div class="input-group">
      <label>같이 앉기 싫은 쌍 (번호,번호 / 번호,번호):</label>
      <input id="notTogether" type="text" placeholder="예: 1,2/3,4" value="1,2/3,4" />
    </div>
    <div class="input-group">
      <label>고급 탐색 수준 (숫자 클수록 정밀 탐색):</label>
      <input id="popSize" type="number" value="30" />
    </div>
    <div class="input-group">
      <label>최적화 단계 (많을수록 오래 걸림):</label>
      <input id="generations" type="number" value="15" />
    </div>

    <div class="buttons">
      <button onclick="app.init()">좌석 생성하기</button>
      <button onclick="app.assignSeatsAdvanced()">고급 자리 배치</button>
      <button onclick="app.downloadPDF()">PDF 저장</button>
    </div>

    <!-- 표가 들어갈 영역 -->
    <div id="gridArea"></div>
    <!-- 조건 이행률(정확도) & 시간 표시 -->
    <div id="scoreArea"></div>
  </div>

  <div class="footer">made by 20707 with GPT</div>

  <!-- jsPDF (PDF 변환) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const app = {
      seatMatrix: [],
      excludedSeats: new Set(),
      tdElements: {},

      // 1) 좌석 생성
      init() {
        this.seatMatrix = [];
        this.excludedSeats.clear();
        this.tdElements = {};
        document.getElementById('gridArea').innerHTML = '';
        document.getElementById('scoreArea').textContent = '';

        const chk = this.checkInputs();
        if (!chk.ok) {
          alert(chk.msg);
          return;
        }

        const { numPeople, numRows } = chk;
        const numCols = Math.ceil(numPeople / numRows);

        // 테이블 만들기
        let html = '<table>';
        html += `<tr><td class="desk-td" colspan="${numCols}">교탁</td></tr>`;
        for (let r = 0; r < numRows; r++) {
          html += '<tr>';
          const rowArr = [];
          for (let c = 0; c < numCols; c++) {
            const cellId = `r${r}c${c}`;
            rowArr.push(cellId);
            html += `<td id="${cellId}">-</td>`;
          }
          this.seatMatrix.push(rowArr);
          html += '</tr>';
        }
        html += '</table>';
        document.getElementById('gridArea').innerHTML = html;

        // 클릭 핸들러
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < this.seatMatrix[r].length; c++) {
            const cid = this.seatMatrix[r][c];
            const td = document.getElementById(cid);
            if (td) {
              td.onclick = () => this.toggleSeat(cid);
              this.tdElements[cid] = td;
            }
          }
        }
      },

      toggleSeat(cellId) {
        if (!this.tdElements[cellId]) return;
        if (this.excludedSeats.has(cellId)) {
          this.excludedSeats.delete(cellId);
          this.tdElements[cellId].classList.remove('excluded');
        } else {
          this.excludedSeats.add(cellId);
          this.tdElements[cellId].classList.add('excluded');
        }
      },

      // 2) 고급 자리 배치
      assignSeatsAdvanced() {
        const chk = this.checkInputs();
        if (!chk.ok) {
          alert(chk.msg);
          return;
        }
        if (!this.seatMatrix.length) {
          alert('먼저 [좌석 생성하기] 버튼을 눌러주세요.');
          return;
        }

        const { numPeople, frontArr, backArr, notPairs, popSize, generations } = chk;

        // 사용 가능한 좌석
        const seats = [];
        for (let r = 0; r < this.seatMatrix.length; r++) {
          for (let c = 0; c < this.seatMatrix[r].length; c++) {
            const cid = this.seatMatrix[r][c];
            if (!this.excludedSeats.has(cid)) {
              seats.push({ row: r, col: c, id: cid });
            }
          }
        }
        if (seats.length < numPeople) {
          alert('사용 가능한 자리보다 인원이 많습니다!');
          return;
        }

        const startTime = performance.now();

        // 사람(1~numPeople)
        const peopleArr = Array.from({length:numPeople}, (_, i)=>(i+1).toString());

        // 초기 population
        let population = [];
        for (let i=0; i<popSize; i++){
          population.push( this.createRandomArrangement(peopleArr, seats, frontArr, backArr) );
        }

        // 세대 반복
        for (let g=0; g<generations; g++){
          // 적합도 계산
          for (let p of population){
            p.fitness = this.calculateFitness(p.mapping,seats, frontArr, backArr, notPairs);
          }
          // 큰 순 정렬
          population.sort((a,b)=>b.fitness - a.fitness);

          const half = Math.floor(popSize/2);
          let newPop = population.slice(0, half);

          while(newPop.length<popSize){
            const i1=Math.floor(Math.random()*half);
            const i2=Math.floor(Math.random()*half);
            const child = this.crossover(population[i1], population[i2], seats);
            if (Math.random()<0.2){
              this.mutation(child,seats);
            }
            child.fitness = this.calculateFitness(child.mapping,seats, frontArr, backArr, notPairs);
            newPop.push(child);
          }
          population=newPop;
        }
        population.sort((a,b)=>b.fitness - a.fitness);
        const best=population[0];

        // 테이블 반영
        for (let s of seats){
          const pid = best.mapping[s.id];
          this.tdElements[s.id].textContent = pid || '-';
        }

        // 이행률
        const ratio = this.computeSatisfaction(best.mapping, seats, notPairs);
        const endTime = performance.now();
        const sec = ((endTime - startTime)/1000).toFixed(2);

        document.getElementById('scoreArea').textContent =
          `조건이행률: ${ratio.toFixed(2)}%, 처리시간: ${sec}초`;
      },

      createRandomArrangement(peopleArr, seats, frontArr, backArr){
        const tmp = [...peopleArr];
        shuffle(tmp);
        const mapping = {};
        for (let i=0; i<tmp.length; i++){
          mapping[seats[i].id] = tmp[i];
        }
        return { mapping, fitness:0 };
      },
      calculateFitness(mapping, seats, frontArr, backArr, notPairs){
        let sc = 0;
        // 싫은 쌍 거리
        for (let [p1,p2] of notPairs){
          let s1=null, s2=null;
          for (let s of seats){
            if(mapping[s.id]===p1)s1=s;
            if(mapping[s.id]===p2)s2=s;
            if(s1&&s2)break;
          }
          if(s1&&s2){
            const d = Math.abs(s1.row-s2.row) + Math.abs(s1.col-s2.col);
            sc += d*10;
          }
        }
        // 앞/뒤 선호
        for (let s of seats){
          const pid = mapping[s.id];
          if(!pid) continue;
          if(frontArr.includes(pid)){
            sc += (5 - s.row);
          }
          if(backArr.includes(pid)){
            sc += (s.row*2);
          }
        }
        return sc;
      },
      crossover(p1, p2, seats){
        const childMap = {};
        const mid = Math.floor(seats.length/2);
        for(let i=0;i<mid;i++){
          childMap[seats[i].id] = p1.mapping[seats[i].id];
        }
        for(let i=mid;i<seats.length;i++){
          childMap[seats[i].id] = p2.mapping[seats[i].id];
        }
        this.fixConflicts(childMap, seats);
        return { mapping: childMap, fitness:0 };
      },
      mutation(chrom, seats){
        const keys = Object.keys(chrom.mapping);
        if(keys.length<2) return;
        const i1 = Math.floor(Math.random()*keys.length);
        const i2 = Math.floor(Math.random()*keys.length);
        if(i1===i2) return;
        const tmp = chrom.mapping[keys[i1]];
        chrom.mapping[keys[i1]] = chrom.mapping[keys[i2]];
        chrom.mapping[keys[i2]] = tmp;
        this.fixConflicts(chrom.mapping, seats);
      },
      fixConflicts(mapping, seats){
        // 중복/누락 방지
        const assigned = [];
        for(let sid in mapping){
          assigned.push(mapping[sid]);
        }
        const used = new Set(), dups=[];
        for(let p of assigned){
          if(used.has(p)) dups.push(p);
          else used.add(p);
        }
        const missing=[];
        const total=assigned.length;
        for(let i=1;i<=total;i++){
          if(!used.has(""+i)) missing.push(""+i);
        }
        let idx=0;
        for(let sid in mapping){
          if(dups.includes(mapping[sid])){
            if(idx<missing.length){
              mapping[sid] = missing[idx++];
            }
          }
        }
      },
      computeSatisfaction(mapping, seats, notPairs){
        if(!notPairs.length) return 100;
        const rowMax = this.seatMatrix.length;
        const colMax = this.seatMatrix[0].length;
        const maxDist = (rowMax-1) + (colMax-1);

        let sumRatio=0, cnt=0;
        for(let [a,b] of notPairs){
          let s1=null,s2=null;
          for(let s of seats){
            if(mapping[s.id]===a)s1=s;
            if(mapping[s.id]===b)s2=s;
            if(s1&&s2)break;
          }
          if(s1&&s2){
            const d = Math.abs(s1.row-s2.row) + Math.abs(s1.col-s2.col);
            sumRatio += (d/maxDist);
            cnt++;
          }
        }
        if(cnt===0)return 100;
        return (sumRatio/cnt)*100;
      },

      downloadPDF(){
        const table = document.querySelector('#gridArea table');
        if(!table){
          alert('먼저 [좌석 생성하기] & [고급 자리 배치]를 해주세요.');
          return;
        }
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        let y=10;
        for(const row of table.rows){
          let x=10;
          for(const cell of row.cells){
            doc.text(cell.textContent, x, y);
            x+=20;
          }
          y+=10;
        }
        doc.save('자리배치.pdf');
      },

      // 기본 입력 체크
      checkInputs(){
        const np = parseInt(document.getElementById('numPeople').value,10);
        const nr = parseInt(document.getElementById('numRows').value,10);
        const fp = document.getElementById('frontPref').value.trim();
        const bp = document.getElementById('backPref').value.trim();
        const nt = document.getElementById('notTogether').value.trim();
        const popSz = parseInt(document.getElementById('popSize').value,10);
        const gens = parseInt(document.getElementById('generations').value,10);

        if(isNaN(np)||np<1)return{ok:false,msg:'인원 수를 1 이상으로'};
        if(isNaN(nr)||nr<1)return{ok:false,msg:'줄 수(행)를 1 이상으로'};
        if(isNaN(popSz)||popSz<2)return{ok:false,msg:'고급 탐색 수준은 2 이상으로'};
        if(isNaN(gens)||gens<1)return{ok:false,msg:'최적화 단계는 1 이상으로'};

        const frontArr = parseList(fp);
        const backArr  = parseList(bp);

        if(hasDup(frontArr)) return {ok:false,msg:'앞자리 선호 중복있음'};
        if(hasDup(backArr)) return {ok:false,msg:'뒷자리 선호 중복있음'};
        for(let f of frontArr){
          if(backArr.includes(f))return{ok:false,msg:`${f}가 앞뒤 선호 중복`};
        }
        for(let v of [...frontArr,...backArr]){
          const x=parseInt(v,10);
          if(x<1||x>np)return{ok:false,msg:`선호번호 ${v}가 인원수 범위 초과`};
        }

        let notPairs=[];
        if(nt!==''){
          const arr=nt.split('/');
          for(let pair of arr){
            const [a,b]=pair.split(',').map(x=>x.trim());
            if(!a||!b)return{ok:false,msg:'같이 앉기싫은쌍 형식오류'};
            if(a===b)return{ok:false,msg:`같이싫은쌍 중 같은번호 ${a}`};
            const aa=parseInt(a,10), bb=parseInt(b,10);
            if(aa<1||aa>np||bb<1||bb>np){
              return{ok:false,msg:`쌍(${a},${b}) 범위초과`};
            }
            notPairs.push([a,b]);
          }
        }

        return{
          ok:true,
          numPeople:np,
          numRows:nr,
          frontArr,
          backArr,
          notPairs,
          popSize:popSz,
          generations:gens
        };
      }
    };

    // 유틸
    function parseList(str){
      if(!str) return [];
      return str.split(',')
        .map(x=>x.trim())
        .filter(x=>x!=='');
    }
    function hasDup(arr){
      return new Set(arr).size!==arr.length;
    }
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
    }
  </script>
</body>
</html>
